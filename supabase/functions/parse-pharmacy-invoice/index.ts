import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { imageBase64, fileName, mimeType } = await req.json()

    if (!imageBase64) {
      return new Response(
        JSON.stringify({ error: 'Image data is required' }),
        {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      )
    }

    // Get API key from Supabase secret
    const apiKey = Deno.env.get('ALLGOOGLE_KEY')
    if (!apiKey) {
      return new Response(
        JSON.stringify({ error: 'Google API key not configured' }),
        {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      )
    }

    // Clean the base64 string
    const cleanBase64 = imageBase64.replace(/^data:[^;]+;base64,/, '')

    const prompt = `You are an expert pharmacy invoice data extraction AI. Analyze this image of a pharmacy supplier invoice directly.

IMPORTANT GUIDELINES:
- Focus on Indian pharmaceutical products and suppliers
- Extract medicine names, quantities, prices, batch numbers, and expiry dates
- Be precise with numeric values and dates
- If a field cannot be confidently extracted, use null

Extract and format the output as a valid JSON object with this exact schema:

{
  "raw_text": "string (all visible text)",
  "invoiceInfo": {
    "supplierName": "string|null",
    "invoiceNumber": "string|null", 
    "invoiceDate": "YYYY-MM-DD|null",
    "totalAmount": "number|null"
  },
  "medicines": [
    {
      "medicineName": "string (required, include strength if visible)",
      "quantity": "number (required, must be positive integer)",
      "unitCostPrice": "number (required, must be positive)",
      "totalCostPrice": "number (quantity * unitCostPrice)",
      "batchNumber": "string|null",
      "expiryDate": "YYYY-MM-DD|null",
      "manufacturer": "string|null",
      "strength": "string|null (e.g., '500mg', '10ml')",
      "packSize": "string|null (e.g., '10 tablets', '100ml bottle')"
    }
  ]
}

EXTRACTION RULES:
1. Medicine names should be clean and standardized (remove extra spaces, fix common OCR errors)
2. Quantities must be positive integers
3. Prices should be numeric values only (remove currency symbols)
4. Dates should be in YYYY-MM-DD format
5. If multiple medicines are listed, extract all of them
6. Ensure each medicine has at minimum: medicineName, quantity, unitCostPrice

Return only the JSON object, no additional text or formatting.`

    // Call Gemini 2.0 Flash Experimental API (Multimodal)
    const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [
            { text: prompt },
            {
              inline_data: {
                mime_type: "image/jpeg", // Assuming JPEG/PNG images for this specific function (parse-pharmacy-invoice)
                data: cleanBase64
              }
            }
          ]
        }],
        generationConfig: {
          response_mime_type: "application/json"
        }
      })
    })

    const geminiData = await geminiResponse.json()

    if (!geminiResponse.ok) {
      throw new Error(`Gemini API error: ${geminiData.error?.message || geminiResponse.statusText}`)
    }

    const candidates = geminiData.candidates
    if (!candidates || candidates.length === 0) {
      throw new Error('No content generated by Gemini')
    }

    const textResponse = candidates[0].content.parts[0].text
    let extractedData
    try {
      extractedData = JSON.parse(textResponse)
    } catch (e) {
      // Fallback or retry parsing
      extractedData = {
        raw_text: "Error parsing JSON",
        invoiceInfo: {},
        medicines: []
      }
    }

    const rawText = extractedData.raw_text || ''

    // Validate and clean (Gemini 2.0 usually follows schema well, but good to be safe)
    const cleanedData = {
      invoiceInfo: {
        supplierName: extractedData.invoiceInfo?.supplierName || null,
        invoiceNumber: extractedData.invoiceInfo?.invoiceNumber || null,
        invoiceDate: extractedData.invoiceInfo?.invoiceDate || null,
        totalAmount: typeof extractedData.invoiceInfo?.totalAmount === 'number' ? extractedData.invoiceInfo.totalAmount : null
      },
      medicines: Array.isArray(extractedData.medicines) ? extractedData.medicines.map((medicine: any) => ({
        medicineName: medicine.medicineName || '',
        quantity: typeof medicine.quantity === 'number' && medicine.quantity > 0 ? medicine.quantity : 1,
        unitCostPrice: typeof medicine.unitCostPrice === 'number' && medicine.unitCostPrice > 0 ? medicine.unitCostPrice : 0,
        totalCostPrice: typeof medicine.totalCostPrice === 'number' ? medicine.totalCostPrice : (medicine.quantity || 1) * (medicine.unitCostPrice || 0),
        batchNumber: medicine.batchNumber || null,
        expiryDate: medicine.expiryDate || null,
        manufacturer: medicine.manufacturer || null,
        strength: medicine.strength || null,
        packSize: medicine.packSize || null
      })).filter((m: any) => m.medicineName && m.medicineName.trim()) : []
    }

    // Calculate confidence score (Simplified logic)
    let confidence = 0.7
    if (cleanedData.invoiceInfo.supplierName) confidence += 0.1
    if (cleanedData.medicines.length > 0) confidence += 0.1

    return new Response(
      JSON.stringify({
        success: true,
        extractedData: cleanedData,
        confidence: Math.min(confidence, 1.0),
        rawText: rawText,
        fileName: fileName || 'invoice.jpg'
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )

  } catch (error) {
    return new Response(
      JSON.stringify({
        error: 'Failed to process pharmacy invoice',
        details: error.message
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )
  }
})